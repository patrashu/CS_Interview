## 트랜잭션

1. 트랜잭션이 무엇인지 설명해주세요
	- 트랜잭션이란 특정 기능을 수행하기 위해 한 번에 실행되어야하는 쿼리문의 집합을 의미
	- DB 시스템에서 트랜잭션이 논리적인 수행 단위로써 작동함
	- 트랜잭션은 ACID라는 4가지 특징을 가지고 있음

2. 원자성(Atomicity)에 대해서 자세하게 설명해주세요
	- 트랜잭션 내 모든 연산이 완전히 수행되거나, 전혀 수행되지 않아야하는 특징을 의미
	- 온라인에서 돈을 송금 중에 에러가 발생했을 경우 원상태로 돌아가야 함 => Rollback
	- 온라인에서 돈을 송금할 때 나의 돈이 상대방의 계좌로 안전하게 전달됨 => Commit
	- 기본적으로 트랜잭션과 연관된 모든 변경사항이 로그 파일로 관리되기 때문에 연산에 실패했을 경우 Rollback이 가능함
	- 뮤텍스와 같은 락킹 매커니즘을 활용했을 경우 동시에 여러 트랜잭션이 값을 변경할 수 없도록 예방가능

3. 일관성(Consistency)에 대해서 자세하게 설명해주세요
	- 일관성이란 처음 DB가 가지고 있는 규칙을 트랜잭션 연산을 진행한 후에도 만족해야 한다는 특징을 의미
	- DB 생성 시 money라는 column에 contraint로 0 이상을 걸었다면, 연산이 진행된 결과에서도 동일하게 만족해야한다는 의미
	- 내 계좌에 돈이 없는데 다른 사람에게 돈을 송금하는 행위는 일어날 수/일어나선 안됨

4. 독립성(Isolation)에 대해서 자세하게 설명해주세요
	- 동시에 여러 트랜잭션이 실행될 때 서로의 연산에 영향을 미치지 않도록 격리하는 특징을 의미
	- 다중 트랜잭션 환경에서 각 트랜잭션이 독립적으로 실행되어야 함
	- 트랜잭션 격리 수준을 통해 특정 트랜잭션이 다른 트랜잭션의 중간 결과를 볼 수 없게 보장함

5. 트랜잭션 격리 수준에 대해서 자세하게 설명해주세요
	- 트랜잭션 격리 수준은 총 4단계로 구성되어 있으며, Read Uncommited/ Read Commited/ Read Repeatable/ Serialization이 존재함
	- Read Uncommited
		- 커밋되지 않은 데이터에 접근하여 사용할 수 있는 상태를 의미
		- A 트랜잭션에서 k값을 10->100으로 변경하고 아직 커밋되지 않은 상태에서 B 트랜잭션이 k에 접근하면 100을 불러옴
		- 위와 같은 문제를 '더티 리드(Dirty Read)'라고 정의함
	- Read Commited
		- 커밋된 데이터만 읽을 수 있는 상태를 의미하며, 데이터를 여러 번 읽을 때 값이 다른 경우가 발생함
		- A에서 값 k를 조회하고 C가 변경한 후 다시 A가 값 k를 조회할 경우 처음과 두 번째 조회의 결과가 다르게 나타남
		- 위와 같은 문제를 'Non-Repeatable Read'라 함
	- Read Repeatable
		- 하나의 트랜잭션 내에서 동일한 데이터를 여러 번 조회했을 때 항상 동일한 데이터를 반환하는 상태를 의미
		- 데이터 수정/삭제 연산은 오류를 발생시킴으로써 방지하지만, 데이터 삽입에 대해서는 오류를 발생시키지 않아 조회 시 결과가 다른 현상을 겪을 수 있음
		- 위와 같은 문제를 '팬텀 리드(Phantom Read)'라고 정의함
	- Serializable
		- 가장 높은 격리 수준으로 트랜잭션이 순차적으로 실행된 것처럼 동작하여 모든 동시성 관련 문제를 방지함
		- 격리 수준이 가장 높아서 안정적이긴 하지만, 타 격리 수준에 비해 비효율적임

6. 지속성/영속성(Durability)에 대해서 자세하게 설명해주세요
	- 영속성이란 한 번 데이터베이스에 완전히 커밋된 연산의 결과는 영구적으로 저장되어야한다는 특징을 의미
	- 중간에 시스템 장애 혹은 DB가 오염되더라도, DBMS에서 관리하는 로그 파일을 통해 이전 상태로 돌아갈 수 있음

## 인덱싱

1. 데이터베이스 인덱싱에 대해서 자세하게 설명해주세요
	- 인덱싱이란 데이터를 효율적으로 탐색함으로써 검색 속도를 향상시키기 위해 사용되는 기술임
	- 특정 컬럼을 인덱스로 지정하여 인덱스 테이블을 생성하고, 탐색하고자 하는 데이터를 빠르게 조회할 수 있도록 도와줌
	- 주로 key-value 쌍으로 구성되어 있으며, key=데이터 값 / value=데이터가 저장된 포인터를 의미
	- 인덱스를 사용하면 데이터베이스에서 특정 레코드를 찾는 작업이 훨씬 빨라짐

2. 인덱스는 어떤 자료구조를 활용하여 구성할 수 있을까요?
	- DB에서의 인덱스는 B트리를 기반으로 구현하여 원하는 값을 빠르게 찾아나감
	- B트리는 하나의 노드가 여러 key값을 가질 수 있는 멀티웨이 노드 트리로써 루트에서 리프노드까지 동일한 level을 유지함
	- 균형잡힌 트리로 구성되기 때문에 탐색/삽입/삭제/수정 연산이 최악의 경우에도 O(log n)을 보장함
	- 순서 상관없이 동등 연산이 빈번한 경우 해시 테이블을 활용하여 빠르게 데이터를 검색할 수 있음

3. 인덱스를 생성할 때 어떤 부분을 고려해야 할까요?
	- 특정 컬럼을 기준으로 인덱스 테이블을 구성하기 때문에, 어떤 컬럼을 인덱스로 지정하는지에 따라 성능이 차이남
	- 중복이 많거나 삽입/삭제/수정이 자주 일어나는 컬럼을 인덱스로 지정할경우 탐색 및 재구성하는데 추가 오버헤드가 발생함
	- 중복이 적은 primary_key나 데이터의 조회가 자주 일어나는 컬럼을 인덱스로 지정할 경우 효율적으로 활용할 수 있음
	- 인덱스는 데이터베이스의 성능을 개선할 수 있지만, 인덱스를 생성하고 유지하는 데 비용이 들기 때문에 적절한 컬럼 선택이 중요함

4. 인덱스가 데이터베이스에 미치는 부정적 영향은?
	- 인덱스는 데이터를 탐색하는데 굉장히 효과적이지만, 부정적인 영향도 존재함
	- 인덱스 역시 테이블로 관리하기 때문에 추가적인 용량이 필요함
	- 삽입/삭제/수정 연산이 빈번한 경우 B트리 리밸런싱으로 인하여 성능 저하가 발생할 수 있음
	- 데이터 삭제 연산을 진행할 때 인덱스 테이블에서는 실제 데이터를 제거하지 않고, 해당 레코드에 대한 연결만 삭제
	- 삭제연산이 빈번하게 진행될 경우 테이블 크기보다 인덱스의 크기가 커지는 현상이 발생할 수 있음

## Key

1. DB에서 사용하는 Key에 대해서 아는대로 말해보세요.
	- 후보키: 릴레이션 내 튜플을 유일하게 식별할 수 있는 속성들의 부분집합을 의미 (유일성 + 최소성)
	- 기본키: 후보키 중 하나
	- 대체키: 후보키 중 기본키를 제외한 나머지 키
	- 슈퍼키: 릴레이션 내 속성들의 집합으로 구성된 키 (유일성)
	- 외래키: 다른 테이블의 기본키를 참조하는 컬럼(속성)

2. 기본키는 수정이 가능할까?
	- 수정이 가능하지만 기본키는 기본적으로 Unique 해야하면서 Null 값을 가질 수 없으며, 이러한 조건을 만족한다면 기본키 또한 충분히 수정가능함
	- 해당 기본키가 다른 테이블의 외래키로써 참조되고 있는 경우, 값을 수정할 때 외래키 관계를 맺고 있는 테이블에 존재하는 정보 또한 수정하거나 참조 무결성 제약 조건에 따라 적절하게 처리해야 함

3. Unique 키워드가 붙는 Key는 그렇지 않은 Key보다 쿼리 성능이 좋을까?
	- Unique 제약 조건이 붙는 컬럼의 경우 DB에서 자동으로 Index를 생성하게 됨
	- 해당 컬럼을 기준으로 조회 연산을 진행할 때 Index를 기반으로 검색 속도를 크게 향상시킬 수 있음

## 조인

1. 데이터베이스 조인 연산이 무엇이고, 왜 사용하는지 말씀해주세요
	- 특정 컬럼을 기준으로 두 개 이상의 테이블을 하나의 테이블로 결합하여 복합 쿼리를 진행하는 연산을 조인이라 함
	- 조인을 사용하는 이유는 분할되어있는 테이블을 결합하여 유의미한 정보를 얻기 위함임
	- 조인은 내부 조인(Inner Join)과 외부 조인(Outer Join) 두 가지로 나뉨

2. 내부 조인을 사용할 때 고려해야 할 부분은?
	- 두 개 이상의 테이블에서 내부 조인을 사용할 때는 특정 컬럼을 기준으로 교집합 연산을 진행한 결과를 반환함
	- A테이블과 B테이블을 내부 조인할 경우 결과 레코드의 수는 A테이블보다 항상 같거나 적다
	- 즉, 교집합 연산을 진행하다가 중요한 레코드들을 놓치는 경우가 존재할 수 있으며, 해당 부분을 잘 고려하여 사용해야 함

3. 외부 조인
	- 외부 조인은 Left Outer Join, Right Outer Join, Full Outer Join 총 3가지로 나뉨 
	- Left Outer Join은 조인 기준 왼쪽 테이블의 컬럼을 기준으로 조인을 진행하고, 오른쪽 테이블에 존재하지 않는 컬럼에 대해 Null 값으로 처리하는 결과를 얻을 수 있음
	- Right Outer Join은 조인 기준 오른쪽 테이블의 컬럼을 기준으로 조인을 진행하고, 왼쪽 테이블에 존재하지 않는 컬럼에 대해 Null 값으로 처리하는 결과를 얻을 수 있음
	- Full Outer Join은 Left + Right 조인으로, 두 테이블에서 일치하지 않는 레코드도 모두 포함하여 Null값으로 처리하는 결과를 얻을 수 있음

4. 조인 연산의 성능을 향상시키는 방법은 ?
	- 조인되는 컬럼을 인덱스로 설정하여 검색(조회)속도를 빠르게 할 수 있음
	- 불필요한 조인이나 연산을 줄이거나 SQL문을 최적화 함으로써 조인 연산의 성능을 향상시킬 수 있음
	- DB 설계 시 정규화/반정규화를 고려하여 조인 횟수를 최소화할 수 있도록 하는 것 또한 성능 향상에 도움이 됨

## 정규화

1. 정규화(Normalization)가 무엇인가요? DB에서 정규화를 왜 사용할까요?
	- 정규화란 DB의 설계를 최적화하여 데이터의 중복을 최소화하고 데이터 무결성을 향상시키기 위해 수행됨
	- 하나의 테이블에 모든 데이터를 저장하여 관리해도 되지만, CRUD를 진행할 때 발생하는 이상 현상을 최소화하기 위해 기존 테이블에 정규화를 적용하여 작은 테이블 여러개로 관리함
	- 정규화는 총 6단계로 존재하며, '도부이결다조'로 암기 가능함

2. 정규화를 하지 않았을 때 발생할 수 있는 이상 현상을 설명해보세요
	- 자료구조를 가르치는 교수가 홍길동에서 아무개로 변경되었을 경우, 테이블을 분할하여 관리하지 않을 경우 테이블 내에서 자료구조를 수강하는 학생을 모두 탐색한 후에 교수 컬럼의 값을 아무개로 모두 변경해야 함. (느림)
	- 머신러닝이라는 과목을 수강하는 학생이 한 명인 상황에서 해당 레코드가 삭제될 경우 머신러닝을 가르치는 교수의 이름을 확인할 수 없게 됨

3. 정규화를 하면 항상 좋을까요? 그렇지 않다면 왜 그렇게 생각하시나요?
	- 정규화를 사용하면 여러 데이터가 포함되어 있는 테이블을 작은 테이블로 분할하여 관리할 수 있으며, 이상(Anomaly)현상을 방지할 수 있게 됨.
	- 테이블을 많이 분할할수록 원하는 데이터를 추출하기 위해 조인 연산이 증가하며, 이로 인한 오버헤드가 많이 발생하여 조회 연산이 느려지는 현상을 겪을 수 있음
	- 이러한 문제를 해결하기 위해 일부 테이블 간 데이터 중복을 허용하여 저장하는 '반정규화(Denomalization)'를 적용하기도 함

4. 정규화 6단계를 설명해보세요
	- 제1정규형(도): 모든 테이블 내 컬럼의 도메인이 원자 값(복합 x)이어야 함
	- 제2정규형(부): 모든 컬럼이 완전 함수 종속이여야 함 (부분 함수 종속 제거)
	- 제3정규형(이): 이행적 함수 종속 제거 (a->b이고 b->c 일때, a->c를 만족하는 case 제거)
	- BCNF      (결): 결정자가 후보키가 아닌 case를 제거
	- 제4정규형(다): 다치종속 제거
	- 제5정규형(조): 조인종속 제거

## NoSQL

1. NoSQL이 뭐야?
	- NoSQL은 RDBMS이 아닌 데이터 저장 기술을 포괄하는 용어로 사용되며 대규모 분산 데이터 세트를 처리하는데 특화되어 있음
	- 엄격한 스키마와 트랜잭션 격리수준을 요구하는 RDBMS에 비해 NoSQL은 엄격하지 않음  

2. NoSQL과 RDB의 대표적인 차이점을 알려줘
	- NoSQL은 스키마가 없거나 유연한 스키마를 제공하기에 데이터 구조를 미리 정의할 필요가 없음
	- NoSQL은 수직적/수평적(샤딩) 확장성이 뛰어나며, 여러 서버에 데이터를 분산하여 저장할 수 있음
	- SQL은 RDB에서 데이터를 관리하기 위한 표준 언어이며, NoSQL은 각각 고유의 쿼리 기법을 사용함

3. NoSQL의 장/단점
	- 장점
		- 구조화되지 않은 데이터를 효율적으로 저장하고 관리할 수 있음
		- 데이터 스키마를 실시간으로 변경할 수 있어 수정이나 확장에 용이함
	- 단점
		- RDB에 비해 완전한 ACID 트랜잭션 모델을 채택하지 않고 있어 
		- SQL만큼이나 강력한 쿼리 언어를 지원하지 않음
