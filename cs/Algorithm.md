## 알고리즘

### 정렬

1. 평균 시간복잡도가 O(N**2)인 정렬에 대해서 설명해주세요
    - **버블 정렬**은 인접한 두 원소를 비교하여 큰 원소를 보내는 과정을 반복적으로 수행하며 오름차순으로 정렬하는 기법으로, 시간복잡도는 평균/최악/최선 모두 O(N**2)임.
    - **선택 정렬**은 배열 내에서 가장 작은 값을 선택하여 맨 앞 Index부터 차례대로 수를 채워나가며 오름차순으로 정렬하는 기법으로, 시간복잡도는 평균/최악/최선 모두 O(N**2)임. 
    - **삽입 정렬**은 하나의 입력 요소를 적절한 위치에 삽입하여 오름차순으로 정렬하는 기법으로, 평균/최악 시간복잡도는 O(N**2)이며 미리 배열이 정렬되어있는 최선의 경우 O(N)임.

2. 병합 정렬에 대해서 설명해주세요.
    - Merge Sort는 Divide and Conquer 방법을 활용하여 리스트를 끊임없이 반을 나누고, 각 부분을 정렬하는 과정을 반복함.
    - 평균/최악/최선 시간복잡도 모두 O(NlogN)임. (Divide => O(logN), Conquer => O(N))
    - 잘게 나눠진 List를 병합하는 정복(Conquer)단계에서 병합할 두 리스트 길이의 합만큼 새로운 배열을 할당해줘야 하기 때문에, 추가적인 메모리가 발생한다는 단점이 존재함.
    - O(NlogN) 알고리즘이지만, Conquer하는 과정에서 상수 연산들이 많이 존재하므로 퀵정렬이나 힙정렬보다 느린 편에 속함. 

3. 퀵 정렬에 대해서 설명해주세요.
    - 퀵 정렬 또한 Divide and Conquer로 해결. 
    - 피벗을 설정하고 피벗 앞쪽으로 작은 값을, 피벗 뒤쪽으로 큰 값을 배치한 후, 두 개로 분할된 부분 리스트를 반복적으로 정복.
    - 평균/최선 시간복잡도는 O(NlogN)이며, 배열이 내림차순으로 정렬되어 있는 최악의 경우 O(N**2)임.
    - 병합 정렬과는 다르게, 추가적인 메모리를 필요로 하지 않는 인플레이스 정렬이라는 장점이 존재함.

4. Python의 내장 정렬함수의 동작 방식에 대해서 설명해주세요.
    - TimSort는 Merge Sort + Insert Sort로 구성되어 있음.
    - 리스트를 작은 부분의 리스트(run=3, 5, 7, ...)로 나누고, 각 부분 리스트를 삽입 정렬을 활용하여 정렬한 후에, 병합 정렬로 전체 리스트를 합치는 행위를 반복함.
    - 최선의 경우 O(N), 평균/최악의 경우 O(NlogN) 시간복잡도를 가짐.
    - [Naver D2 Blog - TimSort](https://d2.naver.com/helloworld/0315536)

5. 왜 최악의 경우 O(N**2)인데도 불구하고 QuickSort를 많이 사용할까?
    - 평균적인 시간복잡도가 O(NlogN)이며, 동일한 시간복잡도를 가지는 다른 정렬 알고리즘에 비해 빠름
    - Pivot을 선택할 수 있는 Case가 많이 존재하고, 이를 통해 최악의 Case를 예방할 수 있음.
    - 퀵정렬은 In-place 정렬로써, **캐시 지역성(Cache Locality)**를 잘 활용함.
    - Pivot을 기준으로 배열을 반씩 분할할 때, 연속적인 메모리 영역에 집중적으로 접근하기 때문에 CPU 캐시에 적중될 확률이 높으며, 이로 인해 실제 메모리 접근 속도를 최적화함.


### 이분 탐색

1. 이분 탐색이란 어떤 것일까요?
    - 정렬된 배열에서 특정한 값을 효율적으로 찾는 검색 방법
    - 중간 위치의 값과 찾고자 하는 값을 비교하고, 탐색 범위를 반씩 줄여나가는 과정을 반복함.
    - 평균적으로 O(logn)의 시간복잡도를 가지며, 데이터의 크기가 클수록 효율적임

2. 어떻게 작동하나요?
    - 배열의 중간 값을 선택하여 target과 비교.
    - target이 작으면 왼쪽으로, target이 크면 오른쪽으로 범위를 반 씩 줄임.
    - 값을 찾았거나, 탐색에 실패했을 경우 종료.

    ```
    정렬된 배열: [1, 3, 5, 7, 9, 11, 13]
    찾고자 하는 값: 9

    1. 중간값 7과 비교 -> 9는 7보다 크므로, 오른쪽 절반에서 탐색
    2. 오른쪽 절반 배열: [9, 11, 13]
    3. 중간값 11과 비교 -> 9는 11보다 작으므로, 왼쪽 절반에서 탐색
    4. 왼쪽 절반 배열: [9]
    5. 9를 찾음
    ```

### 그래프 탐색

1. BFS는 어떻게 작동하나요?
    - BFS(Breadth First Search)는 그래프에서 시작 Node와 가까운 Node들을 먼저 방문하면서 **넓게** 탐색하는 알고리즘
    - 들어온 순서대로 pop하기 위해서 BFS는 **Queue**를 활용하여 구현함.
    - BFS의 시간복잡도는 O(V+E)임. (V = Number of Vertex, E = Number of Edge)

    ```
    그래프: 
    1 - 2
    |   |
    4 - 3

    BFS 탐색 순서 (시작점 1):
    1 → 2 → 4 → 3
    ```

2. DFS는 어떻게 작동하나요?
    - DFS(Depth First Search)는 그래프에서 **한 방향으로 최대한 깊이 탐색**을 수행하다가 더이상 가지 못하는 경우 이전 분기점으로 돌아와 나머지 경로를 탐색하는 알고리즘.
    - 깊이 탐색한 후에 이전 분기로 돌아와야 하기 때문에 **Stack**으로 구현함.
    - DFS의 시간복잡도는 O(V+E)임. (V = Number of Vertex, E = Number of Edge)

    ```
    그래프: 
    1 - 2
    |   |
    4 - 3

    DFS 탐색 순서 (시작점 1):
    1 → 2 → 3 → 4
    ```

### MST(Minimum Spanning Tree)

1. MST란 무엇인가요?
    - 최소 신장 트리는 그래프 내의 모든 Node(Vertex)를 연결하는 최소한의 간선 집합을 의미하며, Edge들의 가중치 합이 가장 최소가 되는 트리를 의미함.
    - 네트워크 설계, 전기회로 설계 등에서 많이 사용함.
    - N개의 노드가 존재할 때, Edge의 수는 N-1개여야 함.

2. Prim 알고리즘에 대해 설명해주세요.
    - 하나의 시작 정점에서 출발하여 이미 선택된(방문한) 정점들과 연결된 간선(Edge) 중 가장 작은 가중치의 간선을 선택하는 방식.
    - 가장 작은 간선을 매 번 pop해야하는 특징을 가지고 있으며, 최소힙 기반의 우선순위 큐를 활용하여 Prim 알고리즘을 구현할 수 있음.
    - 간선의 개수가 E이고, 정점의 개수가 V일 때, 우선순위 큐를 사용한 구현에서는 **O(ElogV)**의 시간 복잡도를 가짐.
    - E개의 간선이 모두 우선순위 큐에 들어가며, 우선순위 큐에서 간선을 pop하고 정점을 추가하는 과정에서 로그 시간이 소요됨.
    - 간선이 밀집되어있는 그래프에서 MST를 구하고자 할 때 적합.
    
    ```
    그래프 (가중치 있음):
        1
      1/ \2
      /   \
     2  -  3
      \1
       \
        4

    Prim 알고리즘 (시작점 1):
    1 → 2 (가중치 1) → 3 (가중치 2) → 4 (가중치 1)

    최소 신장 트리 가중치 합: 1 + 2 + 1 = 4
    ```

3. Kruskal 알고리즘에 대해 설명해주세요.
    - 모든 Edge의 Weight를 기준으로하여 오름차순 정렬을 수행한 후, Cycle이 발생하지 않도록 Union-Find하는 방식
    - E개의 간선이 주어졌을 때, O(ElogE) 시간복잡도를 가짐
    - 간선이 적은 희소 그래프에서 MST를 구하고자 할 때 적합

    ```
    그래프 (가중치 있음):
        1
      1/ \2
      /   \
     2  -  3
      \1
       \
        4

    Kruskal 알고리즘:
    1 - 2 (가중치 1) → 3 - 4 (가중치 1) → 2 - 3 (가중치 2)

    최소 신장 트리 가중치 합: 1 + 1 + 2 = 4
    ```

### 최단거리 알고리즘

1. 다익스트라 알고리즘에 대해서 설명해주세요.
    - 가중치가 양수인 그래프에서 **하나의 시작**점으로부터 모든 정점까지의 최단 경로를 찾는 알고리즘. 
    - 우선순위 큐를 활용하면 O(ElogV) 시간복잡도에 최단거리를 구할 수 있음.
    - 동작 방식
        - 시작 정점을 기준으로 최단 거리를 기록하는 배열을 생성하고, 시작 정점의 거리를 0으로 설정.
        - 방문하지 않은 정점 중에서 최단 거리가 가장 짧은 정점을 선택하여, 그 정점과 연결된 인접 정점들의 거리 업데이트.
        - 모든 정점을 방문할 때까지 반복.

    ```
    그래프 (가중치 있음):
        1
      1/ \2
      /   \
     2  -  3
      \1
       \
        4

    다익스트라 알고리즘 (시작점 1):
    1 → 2 (거리 2) → 3 (거리 3) → 4 (거리 3)

    최단 거리: 1에서 각 정점까지
    1 → 2: 2
    1 → 3: 3
    1 → 4: 3
    ```

2. Floyd Warshall에 대해서 설명해주세요.
    - 모든 정점에서 모든 정점까지의 최단 경로를 구하는 알고리즘
    - O(V**3)이라는 시간복잡도를 가지고 있으며, Node가 많을 경우 비효율적임.
    - 동작 방식
        - 그래프의 인접 행렬을 생성하고 초기화. (자기 자신은 0, 직접 연결된 간선의 가중치를 설정)
        - 각 정점을 중간에 두고, 경유하는 경로를 탐색하면서 최단 경로 갱신.
        - 모든 정점을 중간 정점으로 한 번씩 사용하여, 최단 거리를 갱신하는 과정 반복

    ```
    그래프 (가중치 있음):
        1
      1/ \2
      /   \
     2  -  3
      \1
       \
        4

    플로이드-워셜 알고리즘:
    모든 정점 간 최단 거리 행렬:

        1  2  3  4
    1 |  0  2  3  3
    2 |  2  0  1  2
    3 |  3  1  0  1
    4 |  3  2  1  0
    ```