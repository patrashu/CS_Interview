## 트랜잭션

1. 트랜잭션이 무엇인지 설명해주세요
	- 트랜잭션이란 특정 기능을 수행하기 위해 한 번에 실행되어야하는 쿼리문의 집합을 의미
	- DB 시스템에서 트랜잭션이 논리적인 수행 단위로써 작동함
	- 트랜잭션은 ACID라는 4가지 특징을 가지고 있음

2. 원자성(Atomicity)에 대해서 자세하게 설명해주세요
	- 트랜잭션 내 모든 연산이 완전히 수행되거나, 전혀 수행되지 않아야하는 특징을 의미
	- 온라인에서 돈을 송금 중에 에러가 발생했을 경우 원상태로 돌아가야 함 => Rollback
	- 온라인에서 돈을 송금할 때 나의 돈이 상대방의 계좌로 안전하게 전달됨 => Commit
	- 기본적으로 트랜잭션과 연관된 모든 변경사항이 로그 파일로 관리되기 때문에 연산에 실패했을 경우 Rollback이 가능함
	- 뮤텍스와 같은 락킹 매커니즘을 활용했을 경우 동시에 여러 트랜잭션이 값을 변경할 수 없도록 예방가능

3. 일관성(Consistency)에 대해서 자세하게 설명해주세요
	- 일관성이란 처음 DB가 가지고 있는 규칙을 트랜잭션 연산을 진행한 후에도 만족해야 한다는 특징을 의미
	- DB 생성 시 money라는 column에 contraint로 0 이상을 걸었다면, 연산이 진행된 결과에서도 동일하게 만족해야한다는 의미
	- 내 계좌에 돈이 없는데 다른 사람에게 돈을 송금하는 행위는 일어날 수/일어나선 안됨

4. 독립성(Isolation)에 대해서 자세하게 설명해주세요
	- 동시에 여러 트랜잭션이 실행될 때 서로의 연산에 영향을 미치지 않도록 격리하는 특징을 의미
	- 다중 트랜잭션 환경에서 각 트랜잭션이 독립적으로 실행되어야 함
	- 트랜잭션 격리 수준을 통해 특정 트랜잭션이 다른 트랜잭션의 중간 결과를 볼 수 없게 보장함

5. 트랜잭션 격리 수준에 대해서 자세하게 설명해주세요
	- 트랜잭션 격리 수준은 총 4단계로 구성되어 있으며, Read Uncommited/ Read Commited/ Read Repeatable/ Serialization이 존재함
	- Read Uncommited
		- 커밋되지 않은 데이터에 접근하여 사용할 수 있는 상태를 의미
		- A 트랜잭션에서 k값을 10->100으로 변경하고 아직 커밋되지 않은 상태에서 B 트랜잭션이 k에 접근하면 100을 불러옴
		- 위와 같은 문제를 '더티 리드(Dirty Read)'라고 정의함
	- Read Commited
		- 커밋된 데이터만 읽을 수 있는 상태를 의미하며, 데이터를 여러 번 읽을 때 값이 다른 경우가 발생함
		- A에서 값 k를 조회하고 C가 변경한 후 다시 A가 값 k를 조회할 경우 처음과 두 번째 조회의 결과가 다르게 나타남
		- 위와 같은 문제를 'Non-Repeatable Read'라 함
	- Read Repeatable
		- 하나의 트랜잭션 내에서 동일한 데이터를 여러 번 조회했을 때 항상 동일한 데이터를 반환하는 상태를 의미
		- 데이터 수정/삭제 연산은 오류를 발생시킴으로써 방지하지만, 데이터 삽입에 대해서는 오류를 발생시키지 않아 조회 시 결과가 다른 현상을 겪을 수 있음
		- 위와 같은 문제를 '팬텀 리드(Phantom Read)'라고 정의함
	- Serializable
		- 가장 높은 격리 수준으로 트랜잭션이 순차적으로 실행된 것처럼 동작하여 모든 동시성 관련 문제를 방지함
		- 격리 수준이 가장 높아서 안정적이긴 하지만, 타 격리 수준에 비해 비효율적임

6. 지속성/영속성(Durability)에 대해서 자세하게 설명해주세요
	- 영속성이란 한 번 데이터베이스에 완전히 커밋된 연산의 결과는 영구적으로 저장되어야한다는 특징을 의미
	- 중간에 시스템 장애 혹은 DB가 오염되더라도, DBMS에서 관리하는 로그 파일을 통해 이전 상태로 돌아갈 수 있음

## 인덱싱

1. 데이터베이스 인덱싱에 대해서 자세하게 설명해주세요
	- 인덱싱이란 데이터를 효율적으로 탐색함으로써 검색 속도를 향상시키기 위해 사용되는 기술임
	- 특정 컬럼을 인덱스로 지정하여 인덱스 테이블을 생성하고, 탐색하고자 하는 데이터를 빠르게 조회할 수 있도록 도와줌
	- 주로 key-value 쌍으로 구성되어 있으며, key=데이터 값 / value=데이터가 저장된 포인터를 의미
	- 인덱스를 사용하면 데이터베이스에서 특정 레코드를 찾는 작업이 훨씬 빨라짐

2. 인덱스는 어떤 자료구조를 활용하여 구성할 수 있을까요?
	- DB에서의 인덱스는 B트리를 기반으로 구현하여 원하는 값을 빠르게 찾아나감
	- B트리는 하나의 노드가 여러 key값을 가질 수 있는 멀티웨이 노드 트리로써 루트에서 리프노드까지 동일한 level을 유지함
	- 균형잡힌 트리로 구성되기 때문에 탐색/삽입/삭제/수정 연산이 최악의 경우에도 O(log n)을 보장함
	- 순서 상관없이 동등 연산이 빈번한 경우 해시 테이블을 활용하여 빠르게 데이터를 검색할 수 있음

3. 인덱스를 생성할 때 어떤 부분을 고려해야 할까요?
	- 특정 컬럼을 기준으로 인덱스 테이블을 구성하기 때문에, 어떤 컬럼을 인덱스로 지정하는지에 따라 성능이 차이남
	- 중복이 많거나 삽입/삭제/수정이 자주 일어나는 컬럼을 인덱스로 지정할경우 탐색 및 재구성하는데 추가 오버헤드가 발생함
	- 중복이 적은 primary_key나 데이터의 조회가 자주 일어나는 컬럼을 인덱스로 지정할 경우 효율적으로 활용할 수 있음
	- 인덱스는 데이터베이스의 성능을 개선할 수 있지만, 인덱스를 생성하고 유지하는 데 비용이 들기 때문에 적절한 컬럼 선택이 중요함

4. 인덱스가 데이터베이스에 미치는 부정적 영향은?
	- 인덱스는 데이터를 탐색하는데 굉장히 효과적이지만, 부정적인 영향도 존재함
	- 인덱스 역시 테이블로 관리하기 때문에 추가적인 용량이 필요함
	- 삽입/삭제/수정 연산이 빈번한 경우 B트리 리밸런싱으로 인하여 성능 저하가 발생할 수 있음
	- 데이터 삭제 연산을 진행할 때 인덱스 테이블에서는 실제 데이터를 제거하지 않고, 해당 레코드에 대한 연결만 삭제
	- 삭제연산이 빈번하게 진행될 경우 테이블 크기보다 인덱스의 크기가 커지는 현상이 발생할 수 있음

## 조인


## NoSQL


## Key


## 정규화
