## 해시 테이블 (Hash Table)

1. 해시 테이블이 무엇인가?
    - 해시 테이블이란 Key와 Value를 한 쌍으로 Mapping하여 관리하는 자료 구조임.
    - 사용자가 입력한 임의 길이의 Key값을 해시 함수를 통해 고정 길이의 Hash Key값으로 변경하고, 이를 활용하여 Table에 Key:Value로 데이터를 Mapping하여 관리함.
    - 데이터를 읽거나 수정하는데 상수 시간복잡도로 연산을 수행할 수 있음.
    - 시간복잡도에서는 유리하지만, 데이터의 크기가 커질수록 해시 충돌을 막기 위해 Table의 크기가 커지므로 메모리를 많이 필요로 함.

2. 해시 충돌이란?
    - 해시 충돌이란 두 개 이상의 키가 동일한 Hash Key값을 가지는 경우를 의미함.
    - 이를 해결하기 위한 방법으로는 Chaining / Open Address 기법이 존재함.
    - 두 가지 해결 방법에는 장/단점이 존재하며, Python이나 C에서는 기본적으로 Chaining을 통해 해시 충돌을 해결함.

3. 체이닝이 무엇이고, 단점이 궁금합니다.
    - 체이닝은 하나의 Hash Key값에 매핑되는 Data를 LinkedList로 관리하여 해시 충돌을 해결하는 기법임.
    - 최악의 Case에서 사용자가 입력한 임의의 Key들이 하나의 Hash Key값을 가지는 경우이며, 이러할 떄는 탐색/삽입/삭제 연산이 상수 시간복잡도 -> 선형 시간복잡도로 비효율적이게 됨.
    - 실제 상황에선 위와 같은 Case가 발생하기 전에 Load Factor(저장 항목 수 & Table 크기 비율)를 고려하여 적절한 시점에 Table 크기를 조절.

4. 개방 주소법(Open Addressing) 기법
    - 정의: 개방 주소법은 충돌이 발생할 경우 다른 슬롯을 찾아 데이터를 저장하는 방법으로, 해시 테이블 내에서 충돌 해결을 수행합니다.
    - 종류:
    - 선형 조사(Linear Probing): 충돌이 발생하면 한 칸씩 순차적으로 다음 슬롯을 확인하며 빈 슬롯을 찾습니다.
    - 이차 조사(Quadratic Probing): 충돌이 발생할 때 제곱 수를 이용해 확인할 슬롯의 간격을 늘려가며 빈 슬롯을 찾습니다. 예를 들어, 1, 4, 9, 16 순으로 슬롯을 조사합니다.
    - 더블 해싱(Double Hashing): 1차 해시 값에 추가적인 해시 함수를 적용해 새로운 해시 값을 생성하고, 이를 사용해 충돌을 해결합니다.


## LinkedList

1. 연결리스트란 무엇인가?
    - 데이터를 일렬로 연결하여 저장하는 자료 구조
    - 노드 간 연결로 구성되어 있으며, 하나의 노드는 Value + 다음 Node에 대한 참조(Pointer)로 구성되어 있음.
    - 배열과는 다르게, 동적으로 크기를 조정할 수 있으며, 연속적으로 메모리를 할당받지 않음.

2. 연결리스트의 종류
    - Singly: 단일 연결리스트로, 하나의 노드가 하나의 다음 노드만을 가르키도록 구현되어 있어 한 방향으로만 탐색할 수 있음.
    - Doubly: 이중 연결리스트로, 하나의 노드가 이전/다음 노드와 연결선을 가지고 있어 양방향 탐색을 수행할 수 있음.
    - Circular: 원형 연결리스트로, Head Node와 Tail Node가 서로 연결되어 있어 순환형 구조를 가지고 있음.

3. List와의 비교
    - 연결리스트
        - 동적 메모리 할당 / 비연속적인 메모리 공간에 할당
        - 인덱스가 따로 존재하지 않아 특정 데이터에 접근하는 시간이 O(n)
        - 중간에 삽입/삭제하는 경우 탐색 시간을 제외하면 O(1)
        - 다음 노드를 가르키는 포인터가 있어야 하기 때문에 메모리 사용량 증가
        - 메모리 단편화 문제에 강함.
    -  List
        - 정적 메모리 할당 / 연속적인 메모리 공간에 할당
        - 인덱스가 존재하기 때문에 특정 데이터에 접근하는 시간이 O(1)
        - 중간에 데이터를 삽입/삭제하는 경우 데이터를 이동시켜야 하므로 O(n)
        - 캐시 효율성(Cache Locality)이 우수함.
        - 배열의 크기가 꽉차면, 큰 배열을 할당하고 복사하는 과정을 수행해야 함.


## Tree

1. 트리란 무엇인가?
    - 트리는 데이터 간 계층적 관계를 표현하는 비선형 자료구조로, 하나의 Root Node와 두 개 이상의 Child Node를 가질 수 있는 구조임.
    - 또 다른 Sub Node가 Sub Tree에서 Root 역할을 수행하며 계속해서 확장할 수 있음. 
    - 파일 시스템, DB 인덱싱, AI 알고리즘 등 많은 분야에 활용됨.
    - 그래프와는 다르게 순환 구조가 없고, A노드에서 B노드로 이동하는 경로가 유일함.
    - 트리는 자식으로 가는 연결선이 필요하기 떄문에, 보통 LinkedList로 많이 구현함. 

2. 트리 용어
    - Root: 트리의 최상위에 위치하는 노드
    - Parent: 자식 노드(하위 노드)를 포함하고 있는 노드 
    - Child: 부모 노드(상위 노드)를 포함하고 있는 노드
    - Leaf: 자식이 없는(맨 하단) 노드
    - Height: 루트 노드에서 가장 먼 리프 노드까지의 거리
    - Level: 루트 노드로부터의 거리를 의미하며, 루트 노드는 레벨 0으로 시작함.

3. 트리의 종류
    - Binary Tree: 각 노드가 최대 두 개의 자식을 가질 수 있는 트리
    - Binary Search Tree: 이진트리의 한 형태로, 왼쪽 자식 노드는 현재 노드의 Value보다 작은(우선순위가 낮은) 값을, 오른쪽 자식 노드에는 현재 노드의 Value보다 큰(우선순위가 높은) 값을 저장하도록 구성된 트리. 
    - AVL Tree: 자가 균형을 유지하는 BST로, 삽입/삭제를 수행할 때 자동으로 Balance Factor을 유지하기 위해 Rebalancing 작업을 수행.
    - RB Tree: AVL과 유사한 자가 균형 BST로, Red/Black을 통해 트리의 균형을 유지함. 
    - B Tree: DB 및 파일 시스템에서 사용되는 자가 균형 트리이며, 하나의 노드에 여러 Value를 저장할 수 있는 Multiway Tree임.


4. Binary Search Tree
    - 이진 탐색 트리(BST)는 데이터의 삽입, 검색, 삭제가 모두 O(log n)의 평균 시간 복잡도를 가짐
    - 삽입의 경우, Root부터 차례대로 값을 비교해가며 작으면 왼쪽 크면 오른쪽으로 이동하며 적절한 위치를 찾아감.
    - 삭제의 경우, Root로부터 삭제하고자 하는 Node를 찾아 삭제하는 작업을 수행함. 
    - 자식노드가 없다면 바로 메모리에서 해제
    - 1개 있을 경우 그 자식을 삭제하려는 부모 노드에 연결
    - 2개 있을 경우 오른쪽 자식 중 가장 작은 노드를 탐색하여 삭제하려는 부모 노드에 연결.
    
5. AVL 트리
    - 각 노드마다 Balance Factor (왼쪽 서브트리 Height - 오른쪽 서브트리 Height)의 값을 구하고, 절댓값이 1을 넘기지 않도록 조정하는 트리
    -  검색 과정에서는 매우 효율적임. (높이를 워낙 엄격하게 관리하기 때문에 트리의 Height가 log n에 거의 근접함)
    - 삽입 / 삭제 과정에서는 Balance Factor가 깨질 경우 자동으로 Rebalancing을 수행하기 때문에 Cost가 많이 발생함.


6. RB(Red-Black) 트리
    - 각 노드를 적색 또는 흑색으로 칠하여 트리의 균형을 유지합니다. 특정 규칙을 통해 트리의 높이를 𝑂(log 𝑛)으로 제한함.
    - AVL Tree에 비해 삽입/삭제 연산에서 비용이 적게 소모됨.
    - AVL Tree보다 유연하게 Rebalancing을 수행하기 때문에, 효율성이 떨어질 수 있음.


7. B 트리
    - B- 트리는 높이 균형을 유지하는 트리로, 각 노드가 여러 자식을 가질 수 있는 Multiway 트리임.
    - 하나의 노드가 내부적으로 여러 Key값을 저장할 수 있기 때문에, 탐색 과정에서 노드 간 이동이 적고 검색속도가 빨라 효율적으로 작동할 수 있음.


8. B+ 트리
    - B- 트리는 노드에 값을 저장하지만, B+트리는 실제 데이터를 Leaf Node에만 저장하는 구조를 가지고 있음.
    - Leaf Node끼리는 LinkedList 형태로 연결되어있어 범위 쿼리 및 순차 접근을 용이하게 함.
    - DB 인덱싱에 매우 적합한 자료구조임.
    - Leaf Node에만 데이터를 저장했을 때 얻을 수 있는 장점은 Root/Leaf를 제외한 중간 Branch Node들이 데이터를 저장하지 않기 때문에 더 많은 Key값을 포함할 수 있으며, 이는 곧 트리의 높이가 줄어드는 효과를 간접적으로 가져옴.
    - 한 번 데이터를 탐색 [O(log n)]한 후에, Linked List를 따라가며 순차적으로 데이터를 읽을 수 있기 때문에, 다시 상위 노드로 돌아가 탐색을 진행해야 하는 과정이 생략되어 효과적임.


## Graph

1. 그래프란 무엇인가?
    - Node와 Edge로 구성된 비선형 자료구조로, 데이터 요소간의 관계르 표현함.
    - Tree와는 다르게 비계층적이고 순환 가능한 구조임
    - Node = Vertex = 하나의 노드를 의미함
    - Edge = 노드 간 연결선을 의미함. 
    - Degree = 하나의 Node에 연결된 Edge의 개수를 의미함.

2. 그래프의 종류
    - 방향: Edge에 방향이 있는 그래프로, 연결 선에 따라 이동할 수 있는 방향이 존재함.
    - 무방향: Edge에 방향이 없는 그래프로, 연결된 노드 간 상호 이동할 수 있음.
    - 가중치: A에서 B노드로 이동할 때 발생하는 Cost를 의미함.

3. 그래프 표현 방식
    - 인접 행렬
        - 그래프를 2차원 배열로 표현하는 방식으로, 노드 간 연결여부를 0/1로 표현 
        - 무방향 그래프에서는 대각선 기준으로 대칭임.
        - 연결 여부를 파악하는데 유리하지만, O(V**2)만큼의 공간이 필요함 
    - 인접 리스트
        - 그래프를 LinkedList로 표현하는 방식.
        - 공간 효율성이 우수하며, 메모리 사용량이 적음
        - 연결 여부를 파악하려면 LinkedList를 순차탐색 해야하기 때문에 비효율적임.
    
4. 그래프 자료구조를 어디에 사용할 수 있을까?
    - SNS: 사람 사이의 관계를 표현할 때 (follow) graph 자료구조를 활용할 수 있음.
    - 네비게이션: 도시와 도로를 Node / Edge로 표현하여 최단 경로 알고리즘을 통해 가장 가까운 길을 탐색하는데 활용할 수 있음.
    - 네트워크 시스템: 라우터가 Node가 되고, 라우터를 연결하는 네트워크 선이 Edge가 되어 통신망을 구축하는데 활용할 수 있음.


## Heap
    
1. 힙(Heap)이란 무엇인가?
    - 완전 이진트리의 일종으로, 최대값/최소값을 빠르게 찾아내기 위해 만들어진 자료구조
    - 최대/최소 힙 두 가지로 구성되며, 힙을 사용할 경우 최대/최소 값을 상수 시간복잡도로 매우 빠르게 접근할 수 있음.
    - 삽입/삭제 또한 O(log n)으로 처리가능함.

2. 최대/최소 힙의 구조적인 차이?
    - 최대 힙은 부모 노드가 자식 노드보다 값이 크거나 같은 구조를 의미하며, 우선순위 큐나 힙 정렬 등 최대값을 빠르게 탐색해야하는 경우에 활용 
    - 최소 힙은 부모 노드가 자식 노드보다 값이 작거나 같은 구조를 의미하며, 다익스트라나 최단 경로 찾기와 같은 알고리즘에서 활용

3. 힙에서 데이터의 삽입/삭제 과정
    - 데이터를 삽입할 때는 현재 힙을 구성하는 완전 이진 트리의 맨 마지막에 데이터를 삽입.
    - 그 후 부모 노드와 비교하며 삽입한 데이터가 위치할 영역을 찾아 올라가는(Up Heap) 과정을 수행.
    - 데이터를 삭제할 때는 현재 힙의 가장 최상위 노드(Root)와 맨 마지막 노드의 값을 교체하고, 새로 갱신된 Root 노드가 위치할 영역을 찾아 내려가는(Down Heap) 과정을 수행.
    - 삽입/삭제 과정을 수행할 때, 힙을 항상 유지해야 함.

4. 힙 정렬에 대해서 설명해주세요.
    - 초기 데이터를 최대 힙 구조로 만든 후(Heapify), 가장 큰 요소(루트 노드)를 배열의 마지막 요소와 교환
    - 힙의 크기를 하나 줄여 (마지막 요소를 힙에서 제외) 다운힙 과정을 반복.
    - 이 과정을 힙이 빌(empty) 때까지 반복하면, 감소하는 순서대로 요소들이 정렬됨.
    - 최대 힙을 사용하면 오름차순 정렬, 최소 힙을 사용하면 내림차순 정렬이 가능함.


5. 힙과 BST와의 차이점이 무엇일까?
    - 힙은 모든 노드가 자신의 자식 노드보다 크거나 작은 값을 유지함.
    - 이진 검색 트리(BST)는 왼쪽 자식 노드가 부모 노드보다 작고, 오른쪽 자식 노드가 부모 노드보다 큰 값을 유지함.
    - 힙은 최대값 또는 최소값을 빠르게 찾아내는 것이 필요할 때 유리하며, BST는 범위 검색이나 정렬된 데이터가 필요할 때 효과적으로 활용할 수 있음.